/*
Deployment script for TeamExport

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar TEAM "TEAM"
:setvar DatabaseName "TeamExport"
:setvar DefaultFilePrefix "TeamExport"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER01\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER01\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY SIMPLE,
                AUTO_SHRINK ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE,
                DISABLE_BROKER 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY ON 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367)) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Move Schema refactoring operation with key 1f313924-462d-480d-97df-c44b94abe12d is skipped, model element [dbo].[tblClientDict] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 76e3a941-b65e-4f9b-8a92-79402a68f47c is skipped, element [data].[tblClientDict] (SqlTable) will not be renamed to client_dict';


GO
PRINT N'Move Schema refactoring operation with key e7a05376-622f-433e-bbcb-d1c6ad101e39 is skipped, model element [dbo].[tblPrice] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 98f941d4-18be-4cb9-9580-982c5b869fcd is skipped, element [data].[tblPrice] (SqlTable) will not be renamed to price';


GO
PRINT N'Move Schema refactoring operation with key 7917f69e-f4f9-4c03-ac13-74f5d3fa2e0c is skipped, model element [dbo].[tblPriceClientDict] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 74055c46-cd7c-41fe-a0ac-5163d8c8aff6 is skipped, element [data].[tblPriceClientDict] (SqlTable) will not be renamed to price_client_dict';


GO
PRINT N'Move Schema refactoring operation with key f6343f81-6b93-4211-965b-11fdd1becaa1 is skipped, model element [dbo].[tblStock] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key b43df920-d6b3-4d79-be0d-986d56a24a88 is skipped, element [data].[tblStock] (SqlTable) will not be renamed to stock';


GO
PRINT N'Move Schema refactoring operation with key 79322903-5b1b-458a-bf44-bd9275e3fcea is skipped, model element [dbo].[vwProduct] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 29092862-4de3-4ca5-9d6e-ddbe47586fd4 is skipped, element [import].[vwProduct] (SqlView) will not be renamed to product';


GO
PRINT N'Move Schema refactoring operation with key 8dfe64e9-f3af-436f-9557-1d7ad95ee778 is skipped, model element [dbo].[vwPriceClientDict] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 5d10c85c-ed96-45dd-b3be-6055c37632bc is skipped, element [import].[vwPriceClientDict] (SqlView) will not be renamed to price_client_dict';


GO
PRINT N'Move Schema refactoring operation with key 11dae0b5-561a-4ca2-aff2-0ca9e166f444 is skipped, model element [dbo].[vwClientDict] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 0bfcf0c3-1d27-433e-af77-f55313a6817f is skipped, element [import].[vwClientDict] (SqlView) will not be renamed to client_dict';


GO
PRINT N'Move Schema refactoring operation with key fd28bee4-5763-4442-b934-2011967caca3 is skipped, model element [dbo].[uspPopulateProduct] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 53b41f27-1347-4157-be80-13743292e244 is skipped, element [import].[uspPopulateProduct] (SqlProcedure) will not be renamed to populate_product';


GO
PRINT N'Move Schema refactoring operation with key a0503fba-9048-40ed-87c1-5f60e16d0b3f is skipped, model element [dbo].[uspPopulatePriceClientDict] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 775e85f7-1b9b-4811-aa0c-6240c9d923e4 is skipped, element [import].[uspPopulatePriceClientDict] (SqlProcedure) will not be renamed to populate_price_client_dict';


GO
PRINT N'Move Schema refactoring operation with key e3aff8bf-4e17-4262-9380-29848b255f29 is skipped, model element [dbo].[uspPopulateClientDict] is not found in target database.';


GO
PRINT N'Rename refactoring operation with key 28b68cd1-bdbd-4ed5-b7b4-4d21d4e75f46 is skipped, element [import].[uspPopulateClientDict] (SqlProcedure) will not be renamed to populate_client_dict';


GO
PRINT N'Creating [config]...';


GO
CREATE SCHEMA [config]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [data]...';


GO
CREATE SCHEMA [data]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [export]...';


GO
CREATE SCHEMA [export]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [import]...';


GO
CREATE SCHEMA [import]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [log]...';


GO
CREATE SCHEMA [log]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [config].[EventType]...';


GO
CREATE TABLE [config].[EventType] (
    [EventTypeId]   INT           NOT NULL,
    [EventTypeCode] NVARCHAR (3)  NOT NULL,
    [Description]   NVARCHAR (64) NOT NULL,
    [AddDate]       DATETIME      NOT NULL,
    [AddUser]       NVARCHAR (32) NOT NULL,
    [ModDate]       DATETIME      NOT NULL,
    [ModUser]       NVARCHAR (32) NOT NULL,
    CONSTRAINT [PK_EventType] PRIMARY KEY CLUSTERED ([EventTypeId] ASC),
    CONSTRAINT [NX1_EventType] UNIQUE NONCLUSTERED ([EventTypeCode] ASC)
);


GO
PRINT N'Creating [data].[currency]...';


GO
CREATE TABLE [data].[currency] (
    [currency_id]          INT           NOT NULL,
    [currency_code]        VARCHAR (10)  NOT NULL,
    [currency_description] NVARCHAR (20) NOT NULL,
    [LastUpdate]           DATETIME      NOT NULL,
    [ResponseCode]         VARCHAR (3)   NULL,
    [ResponseDate]         DATETIME      NULL,
    [DeletedOn]            DATETIME      NULL,
    CONSTRAINT [PK_currency] PRIMARY KEY CLUSTERED ([currency_id] ASC),
    CONSTRAINT [NX1_currency] UNIQUE NONCLUSTERED ([currency_code] ASC)
);


GO
PRINT N'Creating [data].[product]...';


GO
CREATE TABLE [data].[product] (
    [product_id]             INT            NOT NULL,
    [product_code]           VARCHAR (100)  NOT NULL,
    [product_description]    NVARCHAR (200) NOT NULL,
    [promo]                  NVARCHAR (20)  NULL,
    [ean]                    VARCHAR (14)   NULL,
    [integral_code]          VARCHAR (30)   NULL,
    [series]                 VARCHAR (30)   NULL,
    [category]               NVARCHAR (50)  NULL,
    [brand]                  VARCHAR (20)   NULL,
    [range]                  BIT            NULL,
    [product_description_en] VARCHAR (100)  NULL,
    [category_en]            VARCHAR (70)   NULL,
    [box_capacity]           SMALLINT       NULL,
    [dimension_h]            DECIMAL (7, 3) NULL,
    [dimension_w]            DECIMAL (7, 3) NULL,
    [dimension_l]            DECIMAL (7, 3) NULL,
    [pallete_capacity]       INT            NULL,
    [box_dimension_h]        DECIMAL (7, 3) NULL,
    [box_dimension_w]        DECIMAL (7, 3) NULL,
    [box_dimension_l]        DECIMAL (7, 3) NULL,
    [rep_state]              BIT            NULL,
    [rep_state_www]          BIT            NULL,
    [kgo]                    FLOAT (53)     NULL,
    [LastUpdate]             DATETIME       NOT NULL,
    [ResponseCode]           VARCHAR (3)    NULL,
    [ResponseDate]           DATETIME       NULL,
    [DeletedOn]              DATETIME       NULL,
    [Action]                 VARCHAR (10)   NULL,
    CONSTRAINT [PK_product] PRIMARY KEY CLUSTERED ([product_id] ASC),
    CONSTRAINT [NX1_product] UNIQUE NONCLUSTERED ([product_code] ASC)
);


GO
PRINT N'Creating [data].[price_client_dict]...';


GO
CREATE TABLE [data].[price_client_dict] (
    [price_client_id]          INT          NOT NULL,
    [price_client_code]        VARCHAR (30) NOT NULL,
    [price_client_description] VARCHAR (30) NOT NULL,
    [LastUpdate]               DATETIME     NOT NULL,
    [ResponseCode]             VARCHAR (3)  NULL,
    [ResponseDate]             DATETIME     NULL,
    [DeletedOn]                DATETIME     NULL,
    [Action]                   VARCHAR (10) NULL,
    CONSTRAINT [PK_price_client_dict] PRIMARY KEY CLUSTERED ([price_client_id] ASC),
    CONSTRAINT [NX1_price_client_dict] UNIQUE NONCLUSTERED ([price_client_code] ASC)
);


GO
PRINT N'Creating [data].[price]...';


GO
CREATE TABLE [data].[price] (
    [product_id]      INT             NOT NULL,
    [price_client_id] INT             NOT NULL,
    [netto_price]     DECIMAL (10, 2) NOT NULL,
    [currency_code]   VARCHAR (4)     NOT NULL,
    [LastUpdate]      DATETIME        NOT NULL,
    [ResponseCode]    VARCHAR (3)     NULL,
    [ResponseDate]    DATETIME        NULL,
    [DeletedOn]       DATETIME        NULL,
    [Action]          VARCHAR (10)    NULL,
    CONSTRAINT [PK_price] PRIMARY KEY CLUSTERED ([product_id] ASC, [price_client_id] ASC)
);


GO
PRINT N'Creating [data].[client_dict]...';


GO
CREATE TABLE [data].[client_dict] (
    [client_id]          INT            NOT NULL,
    [client_code]        VARCHAR (30)   NOT NULL,
    [client_description] NVARCHAR (200) NOT NULL,
    [LastUpdate]         DATETIME       NOT NULL,
    [ResponseCode]       VARCHAR (3)    NULL,
    [ResponseDate]       DATETIME       NULL,
    [DeletedOn]          DATETIME       NULL,
    [Action]             VARCHAR (10)   NULL,
    CONSTRAINT [PK_client_dict] PRIMARY KEY CLUSTERED ([client_id] ASC),
    CONSTRAINT [NX1_client_dict] UNIQUE NONCLUSTERED ([client_code] ASC)
);


GO
PRINT N'Creating [data].[stock]...';


GO
CREATE TABLE [data].[stock] (
    [product_id]      INT          NOT NULL,
    [client_id]       INT          NULL,
    [quantity]        INT          NOT NULL,
    [stock_type_code] NVARCHAR (4) NOT NULL,
    [LastUpdate]      DATETIME     NOT NULL,
    [ResponseCode]    VARCHAR (3)  NULL,
    [ResponseDate]    DATETIME     NULL,
    [Action]          VARCHAR (10) NULL
);


GO
PRINT N'Creating [log].[EventLog]...';


GO
CREATE TABLE [log].[EventLog] (
    [EventLogId]      INT            IDENTITY (1, 1) NOT NULL,
    [EventTypeId]     INT            NOT NULL,
    [EventDate]       DATETIME       NOT NULL,
    [DatabaseName]    NVARCHAR (255) NOT NULL,
    [SchemaName]      NVARCHAR (255) NOT NULL,
    [ProcedureName]   NVARCHAR (MAX) NOT NULL,
    [NestLevel]       TINYINT        NULL,
    [EventMessage]    NVARCHAR (MAX) NULL,
    [EventParameters] NVARCHAR (MAX) NULL,
    [EventRowcount]   INT            NULL,
    [ErrorMessage]    NVARCHAR (MAX) NULL,
    [ErrorNumber]     INT            NULL,
    [ErrorLine]       INT            NULL,
    [ErrorSeverity]   INT            NULL,
    [ErrorState]      TINYINT        NULL,
    [AddDate]         DATETIME       NULL,
    [AddUser]         NVARCHAR (128) NULL,
    CONSTRAINT [PK_EventLog] PRIMARY KEY CLUSTERED ([EventLogId] ASC)
);


GO
PRINT N'Creating [log].[job_log]...';


GO
CREATE TABLE [log].[job_log] (
    [job_id]          INT          IDENTITY (1, 1) NOT NULL,
    [start_datetime]  DATETIME     NULL,
    [finish_datetime] DATETIME     NULL,
    [status]          VARCHAR (10) NULL,
    PRIMARY KEY CLUSTERED ([job_id] ASC)
);


GO
PRINT N'Creating [log].[DF_EventLog_AddDate]...';


GO
ALTER TABLE [log].[EventLog]
    ADD CONSTRAINT [DF_EventLog_AddDate] DEFAULT GETDATE() FOR [AddDate];


GO
PRINT N'Creating [log].[DF_EventLog_AddUser]...';


GO
ALTER TABLE [log].[EventLog]
    ADD CONSTRAINT [DF_EventLog_AddUser] DEFAULT SUSER_SNAME() FOR [AddUser];


GO
PRINT N'Creating [config].[trgEventType]...';


GO
--- <summary>Updates ModUser/ModDate to trace changes</summary>
--- <event author="Piotr Purwin" date="2017-10-15" project="TEAM">Trigger Created.</event>
CREATE TRIGGER [config].[trgEventType] ON [config].[EventType]
AFTER UPDATE

AS

BEGIN
	SET	NOCOUNT ON

    UPDATE	X
    SET
         ModDate = GETDATE()
		,ModUser = SYSTEM_USER
	FROM [config].[EventType] X
	INNER JOIN inserted I
		ON	I.[EventTypeId] = X.[EventTypeId]
END
GO
PRINT N'Creating [export].[client_dict]...';


GO
--- <summary>Move client_dict data from TeamExport to TeamAssets</summary>
--- <event author="Piotr Purwin" date="2017-11-07" project="TEAM">View created</event>
CREATE VIEW export.client_dict

AS

SELECT 
	 [client_code]
	,[client_description]
	,[Action]
	,[ResponseCode]
	,[ResponseDate]
	,[DeletedOn]
FROM data.client_dict
WHERE Action IS NOT NULL
GO
PRINT N'Creating [export].[product]...';


GO
--- <summary>Move product data from TeamExport to TeamAssets</summary>
--- <event author="Piotr Purwin" date="2017-11-07" project="TEAM">View created</event>
CREATE VIEW export.product

AS

SELECT 
	 [product_code]
	,[product_description]
	,[promo]
	,[ean]
	,[integral_code]
	,[series]
	,[category]
	,[brand]
	,[range]
	,[product_description_en]
	,[category_en]
	,[box_capacity]
	,[dimension_h] = CONVERT(nvarchar(8),dimension_h)
	,[dimension_w] = CONVERT(nvarchar(8),dimension_w)
	,[dimension_l] = CONVERT(nvarchar(8),dimension_l)
	,[pallete_capacity]
	,[box_dimension_h] = CONVERT(nvarchar(8),dimension_h)
	,[box_dimension_w] = CONVERT(nvarchar(8),dimension_w)
	,[box_dimension_l] = CONVERT(nvarchar(8),dimension_l)
	,[rep_state]
	,[rep_state_www]
	,[kgo] = CONVERT(nvarchar(10),kgo)
	,[Action]
	,[ResponseCode]
	,[ResponseDate]
	,[DeletedOn]
FROM data.product
WHERE Action IS NOT NULL
GO
PRINT N'Creating [export].[price]...';


GO
--- <summary>Move price data from TeamExport to TeamAssets</summary>
--- <event author="Piotr Purwin" date="2018-01-29" project="TEAM">View created</event>
CREATE VIEW export.price

AS

SELECT 
	 P.product_code
	,PCD.price_client_code
	,[netto_price] = CONVERT(varchar(10),S.netto_price)
	--,S.brutto_price
	,S.currency_code
	,S.Action
	,S.ResponseCode
	,S.ResponseDate
FROM data.price S
INNER JOIN data.product P
	ON P.product_id = S.product_id
INNER JOIN data.price_client_dict PCD
	ON PCD.price_client_id = S.price_client_id
WHERE S.Action IS NOT NULL
GO
PRINT N'Creating [export].[price_client_dict]...';


GO
--- <summary>Move price_client_dict data from TeamExport to TeamAssets</summary>
--- <event author="Piotr Purwin" date="2017-12-07" project="TEAM">View created</event>
CREATE VIEW export.price_client_dict

AS

SELECT 
	 [price_client_code]
	,[price_client_description]
	,[Action]
	,[ResponseCode]
	,[ResponseDate]
	,[DeletedOn]
FROM data.price_client_dict
WHERE Action IS NOT NULL
GO
PRINT N'Creating [export].[stock]...';


GO
--- <summary>Move stock data from TeamExport to TeamAssets</summary>
--- <event author="Piotr Purwin" date="2017-11-07" project="TEAM">View created</event>
CREATE VIEW export.stock

AS

SELECT 
	 P.product_code
	,CD.client_code
	,S.quantity
	,S.stock_type_code
	,S.Action
	,S.ResponseCode
	,S.ResponseDate
FROM data.stock S
INNER JOIN data.product P
	ON P.product_id = S.product_id
LEFT JOIN data.client_dict CD
	ON CD.client_id = S.client_id
WHERE S.Action IS NOT NULL
GO
PRINT N'Creating [import].[currency]...';


GO
--- <summary>Move currency data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">View created</event>
CREATE VIEW [import].currency

AS

SELECT 
	 [currency_id] = ID
	,[currency_code] = LTRIM(RTRIM(Symbol))
	,[currency_description] = LTRIM(RTRIM(Nazwa))
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.Waluty
GO
PRINT N'Creating [import].[product]...';


GO
--- <summary>Move product data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-10-16" project="TEAM">View created</event>
CREATE VIEW import.product

AS

SELECT 
	 [product_id] = T.ID
	--,[product_code] = REPLACE(REPLACE(T.Kod,' ',''),'\','-')
	,[product_code] = LTRIM(RTRIM(T.Kod))
	,[product_description] = LTRIM(RTRIM(T.Nazwa))
	,[promo] = CASE WHEN LTRIM(RTRIM(FPROM.Data)) = '' THEN NULL ELSE LTRIM(RTRIM(FPROM.Data)) END
	,[ean] =  CASE WHEN LTRIM(RTRIM(ean)) = '' THEN NULL ELSE LTRIM(RTRIM(T.EAN)) END
	,[integral_code] = CASE WHEN LTRIM(RTRIM(FIntref.Data)) = '' THEN NULL ELSE LTRIM(RTRIM(FIntref.Data)) END
	,[series] = CASE WHEN LTRIM(RTRIM(FSerie.Data)) = '' THEN NULL ELSE LTRIM(RTRIM(FSerie.Data)) END 
	,[category] = CASE WHEN LTRIM(RTRIM(FPOD.Data)) = '' THEN NULL ELSE LTRIM(RTRIM(FPOD.Data)) END
	,[brand] = LTRIM(RTRIM(Fbrand.Data))
	,[range] = CASE WHEN Frange.Data IS NULL THEN 0 ELSE CONVERT(bit,LTRIM(RTRIM(Frange.Data))) END
	,[product_description_en] = CASE WHEN LTRIM(RTRIM(Fdesc.Data)) = '' THEN NULL ELSE LTRIM(RTRIM(Fdesc.Data)) END
	,[category_en] = CASE WHEN LTRIM(RTRIM(FPODen.Data)) = '' THEN NULL ELSE LTRIM(RTRIM(FPODen.Data)) END
	,[box_capacity] = CONVERT(smallint,LTRIM(RTRIM(FPojOp.Data)))
	,[dimension_h] = CONVERT(decimal(7,3),LTRIM(RTRIM(REPLACE(Fwys.Data,',','.'))))
	,[dimension_w] = CONVERT(decimal(7,3),LTRIM(RTRIM(REPLACE(Fszer.Data,',','.'))))
	,[dimension_l] = CONVERT(decimal(7,3),LTRIM(RTRIM(REPLACE(Fdł.Data,',','.'))))
	,[pallete_capacity] = CONVERT(int,LTRIM(RTRIM(FMAX.Data)))
	,[box_dimension_h] = CONVERT(decimal(7,3),LTRIM(RTRIM(REPLACE(FKwys.Data,',','.'))))
	,[box_dimension_w] = CONVERT(decimal(7,3),LTRIM(RTRIM(REPLACE(FKszer.Data,',','.'))))
	,[box_dimension_l] = CONVERT(decimal(7,3),LTRIM(RTRIM(REPLACE(FKdł.Data,',','.'))))
	,[rep_state] = CASE WHEN FRS.Data IS NULL THEN 0 ELSE CONVERT(bit,LTRIM(RTRIM(FRS.Data))) END
	,[rep_state_www] = CASE WHEN FRSWWW.Data IS NULL THEN 0 ELSE CONVERT(bit,LTRIM(RTRIM(FRSWWW.Data))) END
	,[kgo] = (CONVERT(float,LTRIM(RTRIM(FKGO.Data))) * 0.09) -- kgo wartosc jest wyliczana jako wartosc KGO WAGA * 0,09 zgadza sie dla wszystkich produktów
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.Towary T
LEFT JOIN TEAM.dbo.Features FSerie ON FSerie.Parent = T.ID
	AND FSerie.ParentType = N'Towary' AND FSerie.Name = N'Serie'
LEFT JOIN TEAM.dbo.Features FPOD ON FPOD.Parent = T.ID
	AND FPOD.ParentType = N'Towary' AND FPOD.Name = N'Podgrupa'
LEFT JOIN TEAM.dbo.Features FIntref ON FIntref.Parent = T.ID
	AND FIntref.ParentType = N'Towary' AND FIntref.Name = N'Integral ref'
LEFT JOIN TEAM.dbo.Features Fbrand ON Fbrand.Parent = T.ID
	AND Fbrand.ParentType = N'Towary' AND Fbrand.Name = N'brand'
LEFT JOIN TEAM.dbo.Features FMAX ON FMAX.Parent = T.ID
	AND FMAX.ParentType = N'Towary' AND FMAX.Name = N'max na palecie'
LEFT JOIN TEAM.dbo.Features FPojOp ON FPojOp.Parent = T.ID
	AND FPojOp.ParentType = N'Towary' AND FPojOp.Name = N'Pojemność opakowania'
LEFT JOIN TEAM.dbo.Features Fwys ON Fwys.Parent = T.ID
	AND Fwys.ParentType = N'Towary' AND Fwys.Name = N'wys'
LEFT JOIN TEAM.dbo.Features Fszer ON Fszer.Parent = T.ID
	AND Fszer.ParentType = N'Towary' AND Fszer.Name = N'szer'
LEFT JOIN TEAM.dbo.Features Fdł ON Fdł.Parent = T.ID
	AND Fdł.ParentType = N'Towary' AND Fdł.Name = N'dł'
LEFT JOIN TEAM.dbo.Features FKdł ON FKdł.Parent = T.ID
	AND FKdł.ParentType = N'Towary' AND FKdł.Name = N'karton dł'
LEFT JOIN TEAM.dbo.Features FKszer ON FKszer.Parent = T.ID
	AND FKszer.ParentType = N'Towary' AND FKszer.Name = N'karton szer'
LEFT JOIN TEAM.dbo.Features FKwys ON FKwys.Parent = T.ID
	AND FKwys.ParentType = N'Towary' AND FKwys.Name = N'karton wys'
LEFT JOIN TEAM.dbo.Features Fdesc ON Fdesc.Parent = T.ID
	AND Fdesc.ParentType = N'Towary' AND Fdesc.Name = N'description'
LEFT JOIN TEAM.dbo.Features FPODen ON FPODen.Parent = T.ID
	AND FPODen.ParentType = N'Towary' AND FPODen.Name = N'PodgrupaE'
LEFT JOIN TEAM.dbo.Features FRSWWW ON FRSWWW.Parent = T.ID
	AND FRSWWW.ParentType = N'Towary' AND FRSWWW.Name = N'rap stany www'
LEFT JOIN TEAM.dbo.Features FRS ON FRS.Parent = T.ID
	AND FRS.ParentType = N'Towary' AND FRS.Name = N'rap stany'
LEFT JOIN TEAM.dbo.Features FPROM ON FPROM.Parent = T.ID
	AND FPROM.ParentType = N'Towary' AND FPROM.Name = N'Promocja'
LEFT JOIN TEAM.dbo.Features Frange ON Frange.Parent = T.ID
	AND Frange.ParentType = N'Towary' AND Frange.Name = N'range'
LEFT JOIN TEAM.dbo.Features FKGO ON FKGO.Parent = T.ID
	AND FKGO.ParentType = N'Towary' AND FKGO.Name = N'KGO WAGA'
WHERE T.Blokada = 0 -- dont populate blocked products
GO
PRINT N'Creating [import].[client_dict]...';


GO
--- <summary>Move ClientDict data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">View created</event>
CREATE VIEW [import].client_dict

AS

SELECT 
	 [client_id] = ID
	,[client_code] = LTRIM(RTRIM(Kod))
	,[client_description] = LTRIM(RTRIM(Nazwa))
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.Kontrahenci
GO
PRINT N'Creating [import].[price_client_dict]...';


GO
--- <summary>Move PriceClientDict data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">View created</event>
CREATE VIEW [import].price_client_dict

AS

SELECT 
	 [price_client_id] = ID
	,[price_client_code] = 'PC_' + CONVERT(nvarchar(4), ID)
	,[price_client_description] = LTRIM(RTRIM(Nazwa))
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.DefinicjeCen
GO
PRINT N'Creating [import].[price]...';


GO
--- <summary>Move price data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2018-01-29" project="TEAM">View created</event>
CREATE VIEW [import].[price]

AS

SELECT
	 P.product_id
	,PCD.price_client_id
	,[netto_price] = CONVERT(decimal(10,2),C.NettoValue)
	--,[brutto_price] = CONVERT(decimal(10,2),C.BruttoValue)
	,[currency_code] = C.NettoSymbol
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.Ceny C
INNER JOIN data.product P
	ON P.product_id = C.Towar
INNER JOIN data.price_client_dict PCD
	ON PCD.price_client_id = C.Definicja
GO
PRINT N'Creating [import].[stock]...';


GO
--- <summary>Move stock data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">View created</event>
CREATE VIEW [import].[stock]

AS

--SELECT
--	 P.product_id
--	,[client_id] = NULL
--	,[quantity] = SUM(Z.IloscValue)
--	,[stock_type_code] = N'Stan magazynowy'
--	,[LastUpdate] = GETDATE()
--FROM TEAM.dbo.Zasoby Z
--INNER JOIN data.product P
--	ON P.product_id = Z.Towar
--WHERE Z.Magazyn = 1 -- czy tylko 1?
--	AND Z.Okres = 1 -- ??
--	-- brak kierunku bo brane sa i 1 i -1
--GROUP BY P.product_id

--UNION ALL

SELECT
	 P.product_id
	,C.client_id
	,[quantity] = SUM(Z.IloscValue)
	,[stock_type_code] = N'RSVD'
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.Zasoby Z
INNER JOIN data.product P
	ON P.product_id = Z.Towar
INNER JOIN data.client_dict C
	ON C.client_id = Z.PartiaKontrahent
INNER JOIN TEAM.dbo.DokHandlowe D
	ON D.ID = Z.PartiaDokument
INNER JOIN TEAM.dbo.DefDokHandlowych DF
	ON DF.ID = D.Definicja
	AND DF.Nazwa = N'Rezerwacja odbiorcy'
WHERE Z.Magazyn = 1 -- czy tylko 1?
	AND Z.Okres = 1 -- ??
	AND Z.Kierunek = -1
GROUP BY P.product_id, C.client_id -- grupowanie zeby zlaczyc w jeden wiersz wszystkie rezewacje tego samego produktu dla tego samego klienta

UNION ALL

SELECT
	 P.product_id
	,C.client_id
	,[quantity] = SUM(Z.IloscValue)
	,[stock_type_code] = N'ORDR'
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.Zasoby Z
INNER JOIN data.product P
	ON P.product_id = Z.Towar
INNER JOIN data.client_dict C
	ON C.client_id = Z.PartiaKontrahent
INNER JOIN TEAM.dbo.DokHandlowe D
	ON D.ID = Z.PartiaDokument
INNER JOIN TEAM.dbo.DefDokHandlowych DF
	ON DF.ID = D.Definicja
	AND DF.Nazwa = N'Zamówienie od odbiorcy'
WHERE Z.Magazyn = 1 -- czy tylko 1?
	AND Z.Okres = 1 -- ??
	AND Z.Kierunek = -1
GROUP BY P.product_id, C.client_id

UNION ALL

SELECT
	 P.product_id
	,[client_id] = NULL
	,[quantity] = SUM(Z.IloscValue)
	,[stock_type_code] = N'AVLB'
	,[LastUpdate] = GETDATE()
FROM TEAM.dbo.Zasoby Z
INNER JOIN data.product P
	ON P.product_id = Z.Towar
WHERE Z.Magazyn = 1 -- czy tylko 1?
	AND Z.Okres = 1 -- ??
	AND Z.Kierunek = 1 -- stan fizyczny na 1
GROUP BY P.product_id
GO
PRINT N'Creating [dbo].[EventHandler]...';


GO
--- <summary>Default Event Handler for ECAT DM Process</summary>
--- <concept>Error Handling</concept>
--- <link>http://www.sommarskog.se/error_handling_2005.html</link>
--- <link>http://sqlfool.com/2008/12/error-handling-in-t-sql</link>
--- <link>http://www.sommarskog.se/error_handling/Part3.html</link>
--- <event author="Piotr Purwin" date="2017-10-15" project="TEAM">Procedure Created.</event>
CREATE PROCEDURE [dbo].[EventHandler]
(
	@EventTypeId	tinyint			= 1,	--- <param name="@EventType">Dummy parameter</param>
	@ProcedureName	sysname			= NULL,	--- <param name="@ProcedureName">Name of the calling Procedure.</param>
	@SchemaName		sysname			= NULL,	--- <param name="@SchemaName">Name of schema of the calling Procedure.</param>
	@EventMessage	nvarchar(MAX)	= NULL,	--- <param name="@EventMessage">Description of the Event.</param>
	@EventParams	nvarchar(MAX)	= NULL,	--- <param name="@EventParams">Parameters used for the Event.</param>
	@EventRowcount	int				= NULL,	--- <param name="@EventRowcount">Rowcount returned from the Event.</param>
	@RaiseError		bit				= NULL	--- <param name="@RaiseError">Do we want to raise an Error with the details provided?</param>
)

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	BEGIN TRY 
		
		/* declare variables */
		DECLARE	@ErrorMessage nvarchar(MAX) = ERROR_MESSAGE()	--- <var name="@ErrorMessage" type="nvarchar(MAX)">Stores the Error Message Text.</var>
				,@ErrorSeverity tinyint = ERROR_SEVERITY()		--- <var name="@ErrorSeverity" type="tinyint">Stores the Severity of the Error.</var>
				,@ErrorState tinyint = ERROR_STATE()			--- <var name="@ErrorState" type="tinyint">Stores the State Number of the Error.</var>
				,@ErrorNumber int = ERROR_NUMBER()				--- <var name="@ErrorNumber" type="int">Stores the Error Number.</var>
				,@ErrorLine int = ERROR_LINE()					--- <var name="@ErrorLine" type="int">Stores the line number at which the Error occured.</var>
				,@CustomErrorMessage nvarchar(2048)				--- <var name="@CustomErrorMessage" type="nvarchar(2048)">Stores the Custom Message we will raise back to calling procedure.</var>
				,@ErrorProcedure sysname = ERROR_PROCEDURE()

	
		IF @@ERROR <> 0 and @@TRANCOUNT > 0 ROLLBACK TRANSACTION	/* Always roll back the transaction in case of an error */

		/* initialise variables */
		SET @ProcedureName = COALESCE(@ProcedureName, @ErrorProcedure)
		SET @SchemaName = COALESCE(@SchemaName, '')
		SET @EventMessage = COALESCE(@EventMessage, 'No EventMessage provided')
	
		SET	@RaiseError =	
				CASE WHEN @RaiseError IS NULL and @ErrorSeverity >= 11 /* Should always raise for severity >= 11 */
					THEN 1
					WHEN @RaiseError IS NULL and @ErrorSeverity < 11
					THEN 0
					ELSE @RaiseError 
				END

		SET	@CustomErrorMessage =
				COALESCE(QUOTENAME(@ProcedureName), '<dynamic SQL>') +
				': Msg ' + LTRIM(STR(@ErrorNumber)) +
				', Line ' + LTRIM(STR(@ErrorLine)) +
				': ' + ISNULL(@EventMessage + ': ', '') + @ErrorMessage

		SET	@ProcedureName = COALESCE(@ProcedureName, '<dynamic SQL>')

		INSERT INTO [log].[EventLog]
		(
			 [EventTypeId]
			,[EventDate]
			,[DatabaseName]
			,[SchemaName]
			,[ProcedureName]
			,[NestLevel]
			,[EventMessage]
			,[EventParameters]
			,[EventRowcount]
			,[ErrorMessage]
			,[ErrorNumber]
			,[ErrorLine]
			,[ErrorSeverity]
			,[ErrorState]
		)
		VALUES
		(
			@EventTypeId
			,GETDATE()
			,DB_NAME()
			,@SchemaName
			,@ProcedureName
			,@@NESTLEVEL - 1
			,@EventMessage
			,@EventParams
			,@EventRowcount
			,@ErrorMessage
			,@ErrorNumber
			,@ErrorLine
			,@ErrorSeverity
			,@ErrorState
		)
	END	TRY
	BEGIN CATCH		
		DECLARE @NewErrorMessage nvarchar(MAX)

		SET @RaiseError = 1
		SET @NewErrorMessage = ERROR_MESSAGE()
		SET @CustomErrorMessage = 
				'[dbo].[uspEventHandler] failed with: ' +
				@NewErrorMessage +  ', Original message: ' + @ErrorMessage


		IF XACT_STATE() = -1 ROLLBACK TRANSACTION	/* Avoid new error if transaction is doomed. If -1, the transaction is uncommittable and should be rolled back. */
	END CATCH
	IF @RaiseError = 1	/* Reraise if requested (or if an unexepected error occurred).*/
		BEGIN
			IF @ErrorSeverity > 18 
			BEGIN
				SET @ErrorSeverity = 18	/* Adjust severity if needed; plain users cannot raise level 19.*/
			END
			RAISERROR(@CustomErrorMessage,  @ErrorSeverity, @ErrorState) 
		END
END
GO
PRINT N'Creating [import].[populate_currency]...';


GO
--- <summary>Move currenct data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">Procedure created</event>
CREATE PROCEDURE [import].populate_currency

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	/* declare constants */
	DECLARE  @DEBUG bit
			,@PROCEDURE_NAME sysname
			,@SCHEMA_NAME sysname

	/* declare variables */
	DECLARE	 @EventMessage nvarchar(MAX)
			,@EventParams nvarchar(MAX)
			,@EventRowcount int

	BEGIN TRY
		/* initialise constants */
		SET	@PROCEDURE_NAME = ISNULL(OBJECT_NAME(@@PROCID),'Debug')
		SET @SCHEMA_NAME = ISNULL(OBJECT_SCHEMA_NAME(@@PROCID),'Debug')


		/* log start */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Started'

		/* merge data */

		MERGE [data].currency T
		USING [import].currency S
		ON (T.currency_code = S.currency_code) 
		WHEN MATCHED AND ( 

			T.currency_id <> S.currency_id OR (T.currency_id IS NULL AND S.currency_id IS NOT NULL) OR (T.currency_id IS NOT NULL AND S.currency_id IS NULL)
		OR	T.currency_description <> S.currency_description OR (T.currency_description IS NULL AND S.currency_description IS NOT NULL) OR (T.currency_description IS NOT NULL AND S.currency_description IS NULL)
		)


		THEN UPDATE
		SET  T.currency_id = S.currency_id
			,T.currency_description = S.currency_description
			,T.LastUpdate = S.LastUpdate 
				
		WHEN NOT MATCHED BY TARGET
		THEN INSERT
		(
			 currency_id
			,currency_code
			,currency_description
			,LastUpdate
		)
		VALUES
		(
			 S.currency_id
			,S.currency_code
			,S.currency_description
			,S.LastUpdate
		)

		WHEN NOT MATCHED BY SOURCE AND T.DeletedOn IS NULL
		THEN UPDATE
		SET  T.DeletedOn = GETDATE();


		SET @EventRowcount = @@ROWCOUNT

		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventRowcount = @EventRowcount
			,@EventMessage = 'Rowcount'
			,@EventParams = 'currency'

		/* log complete */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Completed'

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0 ROLLBACK TRAN
		EXEC dbo.EventHandler /* this will reraise error and cause to bomb out in global try/catch */
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Unable to populate table data.currency'
	END CATCH

END
GO
PRINT N'Creating [import].[populate_product]...';


GO
--- <summary>Move Product data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-10-16" project="TEAM">Procedure created</event>
CREATE PROCEDURE [import].populate_product

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	/* declare constants */
	DECLARE  @DEBUG bit
			,@PROCEDURE_NAME sysname
			,@SCHEMA_NAME sysname

	/* declare variables */
	DECLARE	 @EventMessage nvarchar(MAX)
			,@EventParams nvarchar(MAX)
			,@EventRowcount int

	BEGIN TRY
		/* initialise constants */
		SET	@PROCEDURE_NAME = ISNULL(OBJECT_NAME(@@PROCID),'Debug')
		SET @SCHEMA_NAME = ISNULL(OBJECT_SCHEMA_NAME(@@PROCID),'Debug')


		/* log start */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Started'

		/* merge data */

		MERGE [data].product T
		USING [import].product S
		ON (T.product_code = S.product_code) 
		WHEN MATCHED AND ( 

				 T.product_id <> S.product_id OR (T.product_id IS NULL AND S.product_id IS NOT NULL) OR (T.product_id IS NOT NULL AND S.product_id IS NULL)
		OR		 T.product_description <> S.product_description OR (T.product_description IS NULL AND S.product_description IS NOT NULL) OR (T.product_description IS NOT NULL AND S.product_description IS NULL)
		OR		 T.promo <> S.promo OR (T.promo IS NULL AND S.promo IS NOT NULL) OR (T.promo IS NOT NULL AND S.promo IS NULL)
		OR		 T.ean <> S.ean OR (T.ean IS NULL AND S.ean IS NOT NULL) OR (T.ean IS NOT NULL AND S.ean IS NULL)
		OR		 T.integral_code <> S.integral_code OR (T.integral_code IS NULL AND S.integral_code IS NOT NULL) OR (T.integral_code IS NOT NULL AND S.integral_code IS NULL)
		OR		 T.series <> S.series OR (T.series IS NULL AND S.series IS NOT NULL) OR (T.series IS NOT NULL AND S.series IS NULL)
		OR		 T.category <> S.category OR (T.category IS NULL AND S.category IS NOT NULL) OR (T.category IS NOT NULL AND S.category IS NULL)
		OR		 T.brand <> S.brand OR (T.brand IS NULL AND S.brand IS NOT NULL) OR (T.brand IS NOT NULL AND S.brand IS NULL)
		OR		 T.range <> S.range OR (T.range IS NULL AND S.range IS NOT NULL) OR (T.range IS NOT NULL AND S.range IS NULL)
		OR		 T.product_description_en <> S.product_description_en OR (T.product_description_en IS NULL AND S.product_description_en IS NOT NULL) OR (T.product_description_en IS NOT NULL AND S.product_description_en IS NULL)
		OR		 T.category_en <> S.category_en OR (T.category_en IS NULL AND S.category_en IS NOT NULL) OR (T.category_en IS NOT NULL AND S.category_en IS NULL)
		OR		 T.box_capacity <> S.box_capacity OR (T.box_capacity IS NULL AND S.box_capacity IS NOT NULL) OR (T.box_capacity IS NOT NULL AND S.box_capacity IS NULL)
		OR		 T.dimension_h <> S.dimension_h OR (T.dimension_h IS NULL AND S.dimension_h IS NOT NULL) OR (T.dimension_h IS NOT NULL AND S.dimension_h IS NULL)
		OR		 T.dimension_w <> S.dimension_w OR (T.dimension_w IS NULL AND S.dimension_w IS NOT NULL) OR (T.dimension_w IS NOT NULL AND S.dimension_w IS NULL)
		OR		 T.dimension_l <> S.dimension_l OR (T.dimension_l IS NULL AND S.dimension_l IS NOT NULL) OR (T.dimension_l IS NOT NULL AND S.dimension_l IS NULL)
		OR		 T.pallete_capacity <> S.pallete_capacity OR (T.pallete_capacity IS NULL AND S.pallete_capacity IS NOT NULL) OR (T.pallete_capacity IS NOT NULL AND S.pallete_capacity IS NULL)
		OR		 T.box_dimension_h <> S.box_dimension_h OR (T.box_dimension_h IS NULL AND S.box_dimension_h IS NOT NULL) OR (T.box_dimension_h IS NOT NULL AND S.box_dimension_h IS NULL)
		OR		 T.box_dimension_w <> S.box_dimension_w OR (T.box_dimension_w IS NULL AND S.box_dimension_w IS NOT NULL) OR (T.box_dimension_w IS NOT NULL AND S.box_dimension_w IS NULL)
		OR		 T.box_dimension_l <> S.box_dimension_l OR (T.box_dimension_l IS NULL AND S.box_dimension_l IS NOT NULL) OR (T.box_dimension_l IS NOT NULL AND S.box_dimension_l IS NULL)
		OR		 T.rep_state <> S.rep_state OR (T.rep_state IS NULL AND S.rep_state IS NOT NULL) OR (T.rep_state IS NOT NULL AND S.rep_state IS NULL)
		OR		 T.rep_state_www <> S.rep_state_www OR (T.rep_state_www IS NULL AND S.rep_state_www IS NOT NULL) OR (T.rep_state_www IS NOT NULL AND S.rep_state_www IS NULL)
		OR		 T.kgo <> S.kgo OR (T.kgo IS NULL AND S.kgo IS NOT NULL) OR (T.kgo IS NOT NULL AND S.kgo IS NULL)

		)


		THEN UPDATE
		SET  T.product_id = S.product_id
			,T.product_description = S.product_description
			,T.promo = S.promo
			,T.ean = S.ean
			,T.integral_code = S.integral_code
			,T.series = S.series
			,T.category = S.category
			,T.brand = S.brand
			,T.range = S.range
			,T.product_description_en = S.product_description_en
			,T.category_en = S.category_en
			,T.box_capacity = S.box_capacity
			,T.dimension_h = S.dimension_h
			,T.dimension_w = S.dimension_w
			,T.dimension_l = S.dimension_l
			,T.pallete_capacity = S.pallete_capacity
			,T.box_dimension_h = S.box_dimension_h
			,T.box_dimension_w = S.box_dimension_w
			,T.box_dimension_l = S.box_dimension_l
			,T.rep_state = S.rep_state
			,T.rep_state_www = S.rep_state_www
			,T.kgo = S.kgo
			,T.LastUpdate = S.LastUpdate
			,T.Action = 'PUT' -- when there is a change, next request should be PUT
				
		WHEN NOT MATCHED BY TARGET
		THEN INSERT
		(
			 product_id
			,product_code
			,product_description
			,promo
			,ean
			,integral_code
			,series
			,category
			,brand
			,range
			,product_description_en
			,category_en
			,box_capacity
			,dimension_h
			,dimension_w
			,dimension_l
			,pallete_capacity
			,box_dimension_h
			,box_dimension_w
			,box_dimension_l
			,rep_state
			,rep_state_www
			,kgo
			,LastUpdate
			,Action
		)
		VALUES
		(
			 S.product_id
			,S.product_code
			,S.product_description
			,S.promo
			,S.ean
			,S.integral_code
			,S.series
			,S.category
			,S.brand
			,S.range
			,S.product_description_en
			,S.category_en
			,S.box_capacity
			,S.dimension_h
			,S.dimension_w
			,S.dimension_l
			,S.pallete_capacity
			,S.box_dimension_h
			,S.box_dimension_w
			,S.box_dimension_l
			,S.rep_state
			,S.rep_state_www
			,S.kgo
			,S.LastUpdate
			,'POST' -- when there is a new object, next request should be POST
		)

		WHEN NOT MATCHED BY SOURCE AND T.DeletedOn IS NULL
		THEN UPDATE
		SET  T.DeletedOn = GETDATE()
			,T.Action = CASE WHEN T.ResponseCode IS NULL THEN NULL -- when object does not exist anymore but havent been published yet then set action to NULL
							 ELSE 'DELETE' END; -- when object does not exist anymore, next request should be DELETE

		SET @EventRowcount = @@ROWCOUNT

		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventRowcount = @EventRowcount
			,@EventMessage = 'Rowcount'
			,@EventParams = 'product'

		/* log complete */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Completed'

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0 ROLLBACK TRAN
		EXEC dbo.EventHandler /* this will reraise error and cause to bomb out in global try/catch */
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Unable to populate table data.product'
	END CATCH

END
GO
PRINT N'Creating [import].[populate_client_dict]...';


GO
--- <summary>Move ClientDict data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">Procedure created</event>
CREATE PROCEDURE [import].populate_client_dict

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	/* declare constants */
	DECLARE  @DEBUG bit
			,@PROCEDURE_NAME sysname
			,@SCHEMA_NAME sysname

	/* declare variables */
	DECLARE	 @EventMessage nvarchar(MAX)
			,@EventParams nvarchar(MAX)
			,@EventRowcount int

	BEGIN TRY
		/* initialise constants */
		SET	@PROCEDURE_NAME = ISNULL(OBJECT_NAME(@@PROCID),'Debug')
		SET @SCHEMA_NAME = ISNULL(OBJECT_SCHEMA_NAME(@@PROCID),'Debug')


		/* log start */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Started'

		/* merge data */

		MERGE [data].client_dict T
		USING [import].client_dict S
		ON (T.client_code = S.client_code) 
		WHEN MATCHED AND ( 

			T.client_id <> S.client_id OR (T.client_id IS NULL AND S.client_id IS NOT NULL) OR (T.client_id IS NOT NULL AND S.client_id IS NULL)
		OR	T.client_description <> S.client_description OR (T.client_description IS NULL AND S.client_description IS NOT NULL) OR (T.client_description IS NOT NULL AND S.client_description IS NULL)
		)


		THEN UPDATE
		SET  T.client_id = S.client_id
			,T.client_description = S.client_description
			,T.LastUpdate = S.LastUpdate
			,T.Action = 'PUT' -- when there is a change, next request should be PUT
				
		WHEN NOT MATCHED BY TARGET
		THEN INSERT
		(
			 client_id
			,client_code
			,client_description
			,LastUpdate
			,Action
		)
		VALUES
		(
			 S.client_id
			,S.client_code
			,S.client_description
			,S.LastUpdate
			,'POST' -- when there is a new object, next request should be POST
		)
		
		WHEN NOT MATCHED BY SOURCE AND T.DeletedOn IS NULL
		THEN UPDATE
		SET  T.DeletedOn = GETDATE()
			,T.Action = 'DELETE'; -- when object does not exist anymore, next request should be DELETE


		SET @EventRowcount = @@ROWCOUNT

		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventRowcount = @EventRowcount
			,@EventMessage = 'Rowcount'
			,@EventParams = 'client_dict'

		/* log complete */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Completed'

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0 ROLLBACK TRAN
		EXEC dbo.EventHandler /* this will reraise error and cause to bomb out in global try/catch */
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Unable to populate table data.client_dict'
	END CATCH

END
GO
PRINT N'Creating [import].[populate_price_client_dict]...';


GO
--- <summary>Move PriceClientDict data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">Procedure created</event>
CREATE PROCEDURE [import].populate_price_client_dict

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	/* declare constants */
	DECLARE  @DEBUG bit
			,@PROCEDURE_NAME sysname
			,@SCHEMA_NAME sysname

	/* declare variables */
	DECLARE	 @EventMessage nvarchar(MAX)
			,@EventParams nvarchar(MAX)
			,@EventRowcount int

	BEGIN TRY
		/* initialise constants */
		SET	@PROCEDURE_NAME = ISNULL(OBJECT_NAME(@@PROCID),'Debug')
		SET @SCHEMA_NAME = ISNULL(OBJECT_SCHEMA_NAME(@@PROCID),'Debug')


		/* log start */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Started'

		/* merge data */

		MERGE [data].price_client_dict T
		USING [import].price_client_dict S
		ON (T.price_client_id = S.price_client_id) 
		WHEN MATCHED AND ( 

			 T.price_client_code <> S.price_client_code OR (T.price_client_code IS NULL AND S.price_client_code IS NOT NULL) OR (T.price_client_code IS NOT NULL AND S.price_client_code IS NULL)
		OR	 T.price_client_description <> S.price_client_description OR (T.price_client_description IS NULL AND S.price_client_description IS NOT NULL) OR (T.price_client_description IS NOT NULL AND S.price_client_description IS NULL)
		)


		THEN UPDATE
		SET  T.price_client_code = S.price_client_code
			,T.price_client_description = S.price_client_description
			,T.LastUpdate = S.LastUpdate
			,T.Action = 'PUT' -- when there is a change, next request should be PUT
				
		WHEN NOT MATCHED BY TARGET
		THEN INSERT
		(
			 price_client_id
			,price_client_code
			,price_client_description
			,LastUpdate
			,Action
		)
		VALUES
		(
			 S.price_client_id
			,S.price_client_code
			,S.price_client_description
			,S.LastUpdate
			,'POST' -- when there is a new object, next request should be POST
		)

		WHEN NOT MATCHED BY SOURCE AND T.DeletedOn IS NULL
		THEN UPDATE
		SET  T.DeletedOn = GETDATE()
			,T.Action = 'DELETE'; -- when object does not exist anymore, next request should be DELETE


		SET @EventRowcount = @@ROWCOUNT

		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventRowcount = @EventRowcount
			,@EventMessage = 'Rowcount'
			,@EventParams = 'price_client_dict'

		/* log complete */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Completed'

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0 ROLLBACK TRAN
		EXEC dbo.EventHandler /* this will reraise error and cause to bomb out in global try/catch */
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Unable to populate table data.price_client_dict'
	END CATCH

END
GO
PRINT N'Creating [import].[populate_price]...';


GO
--- <summary>Move price data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-01-29" project="TEAM">Procedure created</event>
CREATE PROCEDURE [import].populate_price

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	/* declare constants */
	DECLARE  @DEBUG bit
			,@PROCEDURE_NAME sysname
			,@SCHEMA_NAME sysname

	/* declare variables */
	DECLARE	 @EventMessage nvarchar(MAX)
			,@EventParams nvarchar(MAX)
			,@EventRowcount int

	BEGIN TRY
		/* initialise constants */
		SET	@PROCEDURE_NAME = ISNULL(OBJECT_NAME(@@PROCID),'Debug')
		SET @SCHEMA_NAME = ISNULL(OBJECT_SCHEMA_NAME(@@PROCID),'Debug')


		/* log start */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Started'

		/* merge data */

		MERGE [data].price T
		USING [import].price S
		ON (
			T.product_id = S.product_id
			AND T.price_client_id = S.price_client_id
			)
		WHEN MATCHED AND ( 

			T.netto_price <> S.netto_price OR (T.netto_price IS NULL AND S.netto_price IS NOT NULL) OR (T.netto_price IS NOT NULL AND S.netto_price IS NULL)
		--OR	T.brutto_price <> S.brutto_price OR (T.brutto_price IS NULL AND S.brutto_price IS NOT NULL) OR (T.brutto_price IS NOT NULL AND S.brutto_price IS NULL)
		OR	T.currency_code <> S.currency_code OR (T.currency_code IS NULL AND S.currency_code IS NOT NULL) OR (T.currency_code IS NOT NULL AND S.currency_code IS NULL)
		)

		THEN UPDATE
		SET  T.netto_price = S.netto_price
			--,T.brutto_price = S.brutto_price
			,T.currency_code = S.currency_code
			,T.LastUpdate = S.LastUpdate
			,T.Action = 'PUT' -- when there is a change, next request should be PUT
				
		WHEN NOT MATCHED BY TARGET
		THEN INSERT
		(
			 product_id
			,price_client_id
			,netto_price
			--,brutto_price
			,currency_code
			,LastUpdate
			,Action
		)
		VALUES
		(
			 S.product_id
			,S.price_client_id
			,S.netto_price
			--,S.brutto_price
			,S.currency_code
			,S.LastUpdate
			,'POST' -- when there is a new object, next request should be POST
		)

		WHEN NOT MATCHED BY SOURCE AND T.netto_price <> 0 --AND T.brutto_price <> 0
		THEN UPDATE
		SET  T.netto_price = 0
			--,T.brutto_price = 0 
			,T.Action = 'PUT'; -- when object does not exist anymore, next request should be PUT


		SET @EventRowcount = @@ROWCOUNT

		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventRowcount = @EventRowcount
			,@EventMessage = 'Rowcount'
			,@EventParams = 'price'

		/* log complete */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Completed'

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0 ROLLBACK TRAN
		EXEC dbo.EventHandler /* this will reraise error and cause to bomb out in global try/catch */
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Unable to populate table data.price'
	END CATCH

END
GO
PRINT N'Creating [import].[populate_stock]...';


GO
--- <summary>Move stock data from enova to TeamExport</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">Procedure created</event>
CREATE PROCEDURE [import].populate_stock

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	/* declare constants */
	DECLARE  @DEBUG bit
			,@PROCEDURE_NAME sysname
			,@SCHEMA_NAME sysname

	/* declare variables */
	DECLARE	 @EventMessage nvarchar(MAX)
			,@EventParams nvarchar(MAX)
			,@EventRowcount int

	BEGIN TRY
		/* initialise constants */
		SET	@PROCEDURE_NAME = ISNULL(OBJECT_NAME(@@PROCID),'Debug')
		SET @SCHEMA_NAME = ISNULL(OBJECT_SCHEMA_NAME(@@PROCID),'Debug')


		/* log start */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Started'

		/* merge data */

		MERGE [data].stock T
		USING [import].stock S
		ON (
			T.product_id = S.product_id
			AND ISNULL(T.client_id,'') = ISNULL(S.client_id,'')
			AND T.stock_type_code = S.stock_type_code
			)
		WHEN MATCHED AND ( 

			T.quantity <> S.quantity OR (T.quantity IS NULL AND S.quantity IS NOT NULL) OR (T.quantity IS NOT NULL AND S.quantity IS NULL)
		)


		THEN UPDATE
		SET  T.quantity = S.quantity
			,T.LastUpdate = S.LastUpdate
			,T.Action = 'PUT' -- when there is a change, next request should be PUT
				
		WHEN NOT MATCHED BY TARGET
		THEN INSERT
		(
			 product_id
			,client_id
			,quantity
			,stock_type_code
			,LastUpdate
			,Action
		)
		VALUES
		(
			 S.product_id
			,S.client_id
			,S.quantity
			,S.stock_type_code
			,S.LastUpdate
			,'POST' -- when there is a new object, next request should be POST
		)

		WHEN NOT MATCHED BY SOURCE AND T.quantity <> 0 -- only update if quantity <> 0
		THEN UPDATE
		SET  T.quantity = 0 -- if reservation for some product for some client doesnt exist then dont delete it but set quantity to  0
			,T.Action = 'PUT'; -- when object does not exist anymore, next request should be PUT


		SET @EventRowcount = @@ROWCOUNT

		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventRowcount = @EventRowcount
			,@EventMessage = 'Rowcount'
			,@EventParams = 'stock'

		/* log complete */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Completed'

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0 ROLLBACK TRAN
		EXEC dbo.EventHandler /* this will reraise error and cause to bomb out in global try/catch */
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Unable to populate table data.stock'
	END CATCH

END
GO
PRINT N'Creating [dbo].[FullRefresh]...';


GO
--- <summary>Wrapper procedure</summary>
--- <event author="Piotr Purwin" date="2017-11-02" project="TEAM">Procedure created</event>
CREATE PROCEDURE dbo.FullRefresh

AS

BEGIN

	SET	XACT_ABORT, NOCOUNT ON

	/* declare constants */
	DECLARE  @DEBUG bit
			,@PROCEDURE_NAME sysname
			,@SCHEMA_NAME sysname

	/* declare variables */
	DECLARE	 @EventMessage nvarchar(MAX)
			,@EventParams nvarchar(MAX)
			,@EventRowcount int
			,@start_time datetime

	BEGIN TRY
		/* initialise constants */
		SET	@PROCEDURE_NAME = ISNULL(OBJECT_NAME(@@PROCID),'Debug')
		SET @SCHEMA_NAME = ISNULL(OBJECT_SCHEMA_NAME(@@PROCID),'Debug')

		SET @start_time = GETDATE()

		/* log start */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Started'
		

		/* procedures */


		EXEC import.populate_product

		EXEC import.populate_client_dict

		EXEC import.populate_price_client_dict

		EXEC import.populate_currency

		EXEC import.populate_stock

		EXEC import.populate_price

		/* check if any data table is empty */
		EXEC sp_MSforeachtable 'IF NOT EXISTS (SELECT 1 FROM ?) AND LEFT(''?'',6) = ''[data]'' RAISERROR (''Some tables are empty'',16,1)'

		/* data checks */

		EXEC log.run_preflight_check


		/* if everything went ok, insert start and end time with OK status to the log table */
		INSERT INTO log.job_log (start_datetime, finish_datetime, status) SELECT @start_time, GETDATE(), 'Success'

		/* log complete */
		EXEC dbo.EventHandler
			 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
			,@EventMessage = 'Completed'

	END TRY
	BEGIN CATCH
		IF @@TRANCOUNT > 0 ROLLBACK TRAN
		BEGIN
			EXEC dbo.EventHandler /* this will reraise error and cause to bomb out in global try/catch */
				 @ProcedureName = @PROCEDURE_NAME,@SchemaName = @SCHEMA_NAME
				,@EventMessage = 'Unable to run procedure dbo.FullRefresh'

			/* if job fails, insert start and end time with ERROR status to the log table */
			INSERT INTO log.job_log (start_datetime, finish_datetime, status) SELECT @start_time, GETDATE(), 'ERROR'
		END
	END CATCH

END
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '1f313924-462d-480d-97df-c44b94abe12d')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('1f313924-462d-480d-97df-c44b94abe12d')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '76e3a941-b65e-4f9b-8a92-79402a68f47c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('76e3a941-b65e-4f9b-8a92-79402a68f47c')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'e7a05376-622f-433e-bbcb-d1c6ad101e39')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('e7a05376-622f-433e-bbcb-d1c6ad101e39')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '98f941d4-18be-4cb9-9580-982c5b869fcd')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('98f941d4-18be-4cb9-9580-982c5b869fcd')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '7917f69e-f4f9-4c03-ac13-74f5d3fa2e0c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('7917f69e-f4f9-4c03-ac13-74f5d3fa2e0c')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '74055c46-cd7c-41fe-a0ac-5163d8c8aff6')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('74055c46-cd7c-41fe-a0ac-5163d8c8aff6')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'f6343f81-6b93-4211-965b-11fdd1becaa1')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('f6343f81-6b93-4211-965b-11fdd1becaa1')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b43df920-d6b3-4d79-be0d-986d56a24a88')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b43df920-d6b3-4d79-be0d-986d56a24a88')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '79322903-5b1b-458a-bf44-bd9275e3fcea')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('79322903-5b1b-458a-bf44-bd9275e3fcea')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '29092862-4de3-4ca5-9d6e-ddbe47586fd4')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('29092862-4de3-4ca5-9d6e-ddbe47586fd4')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '8dfe64e9-f3af-436f-9557-1d7ad95ee778')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('8dfe64e9-f3af-436f-9557-1d7ad95ee778')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '5d10c85c-ed96-45dd-b3be-6055c37632bc')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('5d10c85c-ed96-45dd-b3be-6055c37632bc')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '11dae0b5-561a-4ca2-aff2-0ca9e166f444')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('11dae0b5-561a-4ca2-aff2-0ca9e166f444')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '0bfcf0c3-1d27-433e-af77-f55313a6817f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('0bfcf0c3-1d27-433e-af77-f55313a6817f')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'fd28bee4-5763-4442-b934-2011967caca3')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('fd28bee4-5763-4442-b934-2011967caca3')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '53b41f27-1347-4157-be80-13743292e244')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('53b41f27-1347-4157-be80-13743292e244')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'a0503fba-9048-40ed-87c1-5f60e16d0b3f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('a0503fba-9048-40ed-87c1-5f60e16d0b3f')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '775e85f7-1b9b-4811-aa0c-6240c9d923e4')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('775e85f7-1b9b-4811-aa0c-6240c9d923e4')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'e3aff8bf-4e17-4262-9380-29848b255f29')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('e3aff8bf-4e17-4262-9380-29848b255f29')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '28b68cd1-bdbd-4ed5-b7b4-4d21d4e75f46')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('28b68cd1-bdbd-4ed5-b7b4-4d21d4e75f46')

GO

GO
USE TeamExport
GO


PRINT 'EventType'
TRUNCATE TABLE config.EventType;

INSERT INTO config.EventType
    (EventTypeId, EventTypeCode, Description, AddDate, AddUser, ModDate, ModUser)
VALUES 
     (1, 'SYS', 'SQL Error Messages'            ,GETDATE()  ,'MIG'  ,GETDATE()  ,'MIG')
    ,(2, 'BLD', 'Custom Build Error Message'    ,GETDATE()  ,'MIG'  ,GETDATE()  ,'MIG')
    ,(3, 'MSG', 'Message (Information Only)'    ,GETDATE()  ,'MIG'  ,GETDATE()  ,'MIG')


GO

GO
PRINT N'Update complete.';


GO
